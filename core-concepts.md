# Core Concepts

[ChatGPT](https://chatgpt.com/c/6875cfba-e7e0-800c-b61f-400b21a12546)

[Scott Adams coined "The Rule of Twelve"](https://web.archive.org/web/20090322195653/http://dilbert.com/blog/entry/rule_of_twelve/).

> ... seemingly impenetrable topics are less intimidating if you know there are only a dozen concepts to learn.
> And often the details of a subject are unimportant if you know the big concepts.

This is true for many subjects. But avoid overconfidence. Expert pattern libraries are huge (~100K). Execution discipline matters.

- 09 Oct 2025. Core concepts of [directing shorts](https://chatgpt.com/c/68e72037-79d0-8322-ac62-f4370191546b)
  - **Open with a specific curiosity gap in the first 1-2 seconds.** Give viewers a concrete unanswered question or visually odd setup ("Why is the coffee floating?") so the brain _needs_ to resolve it. This is supported by short-video best-practice (hook early) and the "information-gap" theory of curiosity. _Prompt tip:_ Start with one line that states the unresolved situation, then specify the exact first frame
  - **Use a 3-beat micro-arc (setup > build > payoff) sized for 6-20s.** Don't cram a film; deliver one story beat every few seconds. The YouTube/Think with Google ABCD work (Attract, Brand, Connect, Direct) shows simple, purposeful structures outperform meandering ones-especially at bumper-ad lengths. _Prompt tip:_ Add a tiny beat sheet with timestamps: "0-2s setup, 2-6s escalation, 6-8s payoff."
  - **Design the _last_ moment first (Peak-End).** Viewers remember the high point and the ending more than the duration; plan a twist, reveal, or "aha" and cut right after it. This is the Peak-End rule from psychology; in practice you'll see it as spikes near the end in retention graphs. _Prompt tip:_ Write the final shot first; ensure the last frame resolves the opening question
  - **Pace with micro-beats and pattern interrupts.** Change _something_ every 1-2s (camera angle, scale, color, motion, prop) to reset attention without chaos. Platform guides stress tight pacing and clear structure for mobile attention windows. _Prompt tip:_ List planned interrupts: "1. whip-pan, 2. hard cut to macro, 3. foreground object crosses lens."
  - **Max processing fluency: big, high-contrast, simple frames.** The brain rewards "easy to process" visuals (clear figure/ground, symmetry, repetition)-they feel better and read faster on a phone. Keep one subject per shot; use bold contrast; minimal text. _Prompt tip:_ Specify composition ("tight medium on subject, high contrast rim-light, uncluttered background, single color accent")
  - **Constrain on purpose: one change, one location, one idea.** Constraints raise creativity and clarity. Micro-budget directing advice and 6-second ad research converge: pick one surprising constraint and lean into it. _Prompt tip:_ State the constraint up top ("single hallway; only practical light; one prop changes form")
  - **Exploit visual salience and motion immediately.** High-salience elements (faces, movement, contrast) pull gaze fast-vital on scroll feeds. Start with motion crossing the frame or a face entering; cut on action. _Prompt tip:_ "Frame opens mid-action; subject crosses left>right; parallax background; quick dolly-in."
  - **Make sound part of the _story_, not wallpaper.** Sync cuts to beats, use distinct diegetic sounds (whoosh, click, crunch) as transitions, and specify audio intent in the prompt. Veo's guide explicitly recommends fusing visuals with sound design. _Prompt tip:_ Include an "Audio" block ("quiet street > sudden _clack_ > riser swell; cut on snare")
  - **Direct the model like a DP: shot grammar in the prompt.** With Sora/Veo you get better control when you name the lens, camera move, lighting, and blocking-_and_ outline complex action step-by-step. Veo shows gains from highly detailed, play-by-play prompts; Sora exposes a storyboard interface for frame-accurate control. _Prompt tip:_ "35mm lens, handheld, subtle breathing; golden-hour backlight; beat-by-beat action list."
  - **Iterate on retention, not vibes.** Use YouTube's "Key moments for audience retention" to find spikes/dips; move top moments earlier, trim dips, and test a few alt cuts. Shorts auto-loop and rewatch spikes often correlate with a strong twist/payoff. _Prompt tip:_ After v1, generate two alternates: (A) earlier reveal, (B) tighter mid-beat; compare retention
- 09 Oct 2025. Core concepts of [dancing](https://chatgpt.com/c/68e71abd-707c-8321-9342-cf600411fd78)
  - **Keep a tiny continuous "plie bounce" + shift your weight**. Soft, slightly bent knees with gentle, continuous weight transfer (not locked legs) make movement look fluid, absorb impact, and give you timing "drive." Neutral pelvis helps this feel effortless. Practice slow side-to-side weight shifts with micro-plie, then add music.
  - **Live in the subdivisions (8ths/16ths) and play with syncopation**. Great "natural" dancers don't just hit downbeats; they feel the smaller slices of time and place accents slightly ahead/behind the beat. Moderate rhythmic complexity (not too simple, not too busy) maximizes the urge to move. Drill claps/steps on off-beats and ghost notes, then let the body improvise.
  - **Use external-focus cues, not body-part micromanagement**. Thinking "push the floor away" or "trace a circle in space" beats "activate your glutes" for smoother performance and learning. Imagery and outcome-focused cues reduce stiffness and free style. Try one vivid image per phrase.
  - **Get "grounded": neutral pelvis + core support frees the limbs**. Stacking ribs over pelvis over feet (neutral, not tucked/arched) lets arms, head, and hips move cleanly without wobble. It also reduces overload and looks instantly more confident. Quick daily resets: pelvic clock, rib-to-pelvis connection, then groove.
  - **Train your spin system: spot + vestibular adaptation**. Dancers literally rewire how they handle dizziness; spotting and repeated turning uncouple "I'm spinning" feelings from reflex eye movements. Work up with slow head turns, clear spots, then faster spins-your balance improves.
  - **Practice with variability, not rote repetition (constraints & "DL")**. Randomize tasks: tiny step-width changes, tempo shifts, eyes-closed bouts, different arm rules. Highly variable ("differential") practice improves retention, creativity, and adaptability-exactly what party improv needs.
  - **Layer, don't lump: pulse in one place, play elsewhere**. Let feet/hips keep a steady pulse while ribs/shoulders/arms add off-beat patterns-simple polyrhythm reads as "advanced." Start with foot pulse > add rib slides on the "&" > sprinkle arm shapes on every 4th "&."
  - **Use micro "pre-loads" (stretch-shortening) for snap**. A tiny counter-move before an accent-mini dip, quick recoil-stores elastic energy and makes hits pop with less effort. Think "coil-release" rather than muscling through accents.
  - **Balance is a trainable superpower (reduce vision, vary surfaces)**. Dancers learn to re-weight senses and stabilize faster; you can too. Add eyes-closed grooves, slow single-leg weight shifts, and controlled level changes-then your freestyle looks calm instead of wobbly.
  - **Choose "groove-rich" music to practice**. Medium syncopation maximizes pleasure + desire to move; use those tracks to build feel before tackling very simple or very complex rhythms. You'll learn faster and look better, sooner.
  - Practice:
    - 60s: micro-plie weight shifts (no music).
    - 60s: add neutral-pelvis resets (pelvic clock).
    - 90s: clap 8ths > step quarters > accent off-beats.
    - 90s: add rib slides on the "&" (layering).
    - 60s: imagery cue ("paint a curve with your knees").
    - 60s: constraints-hands in pockets; vary step width.
    - 60s: eyes-closed groove (safe stance).
    - 60s: spot + slow head turns.
    - 60s: micro pre-load > accent (coil-release).
    - 60s: freestyle to a medium-syncopation track.
- 07 Oct 2025. Core concepts of [teaching programming](https://chatgpt.com/c/68e49ff2-5144-8322-afe0-8576e04d7d4b)
  - **Don’t teach like an expert—design for novices’ mental models.** Experts skip steps they no longer notice (“expert blind spot”), so their explanations often assume knowledge beginners don’t have. Make the hidden steps and tacit decisions explicit.
  - ⭐ **For beginners, explicit teaching and worked examples beat “discovery learning.”** When prior knowledge is low, minimal guidance overloads working memory; clear explanations plus step-by-step examples work better. Use discovery later, once schemas exist.
  - **Manage cognitive load deliberately (and fade help).** Start with small, fully worked examples; then _fade_ the steps so learners do more on their own. Reduce extraneous details, name chunks, and sequence tasks from easy to hard.
  - **Label the subgoals.** Show the _structure_ of a solution (“parse input → validate → compute → report”), not just the code. Subgoal-labeled examples improve transfer and problem solving because learners remember the plan, not only the syntax.
  - **Use Parsons Problems (reorder/gap-fill code) before open-ended coding.** Asking students to arrange correct lines (or fill small gaps) teaches structure without the heavy burden of recalling everything from scratch; it improves performance and reduces time. Then ramp up to writing.
  - **Teach the “notional machine” and tracing _early_.** Beginners need a simple mental model of how variables, memory, and control flow actually behave; tracing code step-by-step builds that model and prevents persistent misconceptions. Treat tracing and state diagrams as first-class skills.
  - **Make learning stick with retrieval practice and spacing, not cramming.** Frequent low-stakes quizzes, short “explain this output” checks, and spaced review produce far better long-term retention than re-reading or massed practice. Build a cadence of quick, cumulative questions.
  - **Use active learning (e.g., Peer Instruction) to surface and fix misconceptions.** Short conceptual questions → vote → discuss → revote reliably lift exam scores and _halve_ failure rates in STEM and CS classes compared to pure lecturing. It also narrows achievement gaps.
  - **Sequence: read/run/modify _before_ “make,” and bridge representations.** Frameworks like PRIMM (Predict-Run-Investigate-Modify-Make) have learners comprehend and tweak working code first; only then ask them to build. Many studies also support starting with block-based or otherwise constrained representations, then transitioning to text while you scaffold that bridge.
  - **Teach in meaningful contexts—motivation and retention rise.** Courses framed around personally relevant media/data problems (e.g., “Media Computation”) show higher success and retention, especially for learners who might otherwise disengage. “Why this matters” isn’t fluff—it’s an intervention.
- Core Concepts of [`bash`](https://chatgpt.com/c/68d946c8-6230-8330-977f-128da647aed6)
  - **Parameter expansion** for string surgery: trim/strip/replace/slice, defaulting, length, case-change.
  - **[[…]]** tests with **globs** and **regex** (`BASH_REMATCH`), and `case`.
  - **Brace expansion** (`{1..N}`, steps, lists) and **globbing** (incl. `globstar` `**`).
  - **Arrays** and **associative arrays**; `BASH_ARGV` + `extdebug` trick (reverse), dedup via keys.
  - **mapfile/read** with `IFS`, here-strings and process substitution; `$'\n'` newlines.
  - **Arithmetic context** `(( ))`, ternary, `RANDOM`.
  - **Builtins & internals**: `printf` (incl. `strftime`), `type/hash/command -v`, `:` no-op + `$_`.
  - **Redirections** (`>`, `$(<file)`) and subshells.
  - **Traps** (`EXIT`, `INT`, `SIGWINCH`, `DEBUG`, `RETURN`).
  - **Terminal control** with raw ANSI escapes (colors, cursor, erase) and `$LINES/$COLUMNS`.
  - **Pure-bash replacements** for `dirname`, `basename`, `head`, `tail`, `wc -l`, `sleep`, `seq`, `date`, `touch`, `cat`.
  - **Odds & ends**: URL encode/decode, UUID v4 from `$RANDOM`, progress bars, background runner (`nohup`), bypass aliases/functions.
  - **String surgery with parameter expansion (no `sed`/`tr`)**
    `${var#pattern}`/`${var%pattern}` trim the _shortest_ match from start/end.
    `##`/`%%` trim the _longest_.
    `${var//pat/repl}` replaces all, `${var/pat}` removes first, etc.
    It’s instant (no fork), portable, and once you learn the shapes, you’ll reach for them before `sed`.
  - **Regex & globs inside `[[ … ]]` (no `grep`)**
    `[[ $s =~ re ]]` fills `BASH_REMATCH`, and `[[ $s == *foo* ]]`, `== foo*`, `== *foo` cover contains/starts/ends.
    For many validations/extractions you can stay in bash and skip spawning `grep`/`awk`.
  - **Globbing instead of `ls`/`find` for simple scans**
    Iterate with `for f in dir/*.png; do …; done` or enable `shopt -s globstar` to use `**` for simple recursion.
    Need counts? Just expand the glob and use `$#` in a function: `count ~/Pics/*.jpg` → no `ls`, no `wc`.
    Handy inside tight loops or minimal containers where `date` may differ or cost you a fork.
  - **Read a whole file without `cat`: `var=$(<file)`**
    `$(<file)` is a bash optimization that slurps file contents into a variable with no subshell.
    It’s both cleaner and faster than `var="$(cat file)"`.
  - **Split on a delimiter with substitution + `read -ra` (no `cut`)**
    Replace the delimiter with newlines and let `read -ra` build the array:
    `IFS=$'\n' read -d '' -ra parts <<< "${str//$delim/$'\n'}"`.
    This is fast, works with multi-char delimiters, and avoids awkward `IFS` side-effects.
  - **Case transformations in expansion (no `tr`)**
    `${var,,}` lowercases; `${var^^}` uppercases; `${var~~}` flips case.
    It’s surprisingly handy for normalizing keys, filenames, and flags—without forking `tr`.
  - **`mapfile/read` to do `head`/`tail`/`wc -l` in pure bash**
    `mapfile -tn N a <file` is your `head N`.
    `mapfile -tn 0 a <file; printf '%s\n' "${a[@]: -N}"` is `tail N`.
    `${#a[@]}` is your line count.
    You avoid three external processes and keep everything in memory.
  - **Dates without `date`: `printf` with `strftime`**
    Bash’s `printf` speaks `strftime`:
    `printf '%(%F %T)T\n' -1` → `YYYY-MM-DD HH:MM:SS`.
  - **Ranges without `seq`: brace expansion and C-style loops**
    `{1..100}` (and `{1..10..2}` in bash 4+) expands to numbers instantly.
    For dynamic limits: `for ((i=0;i<=N;i++)); do …; done`. This covers 99% of `seq` use.
  - **Sleeping without `sleep`: `read -t` (plus reusable FD for micro-sleeps)**
    `read -rt 0.2 <> <(:) || :` pauses ~200ms; for many tiny sleeps, open a FD once:
    `exec {sfd}<> <(:); read -t 0.001 -u $sfd` in a loop. This avoids spawning `sleep` thousands of times.
- Core Concepts of [Technology evaluation](https://chatgpt.com/c/68cf6c83-e8ac-832e-a87b-7c13bfc5d091)
  - **Optimize for change, not the demo.** Most cost and risk arrive _after_ adoption (maintenance, evolution, integration). Favor tools that make change cheap: clear upgrade paths, good docs, stable internals.
  - **Assume abstractions will leak.** Nice APIs hide complexity—until they don’t. Evaluate timeouts, back-pressure, failure modes, and “escape hatches,” not just the happy path. (Also note the IETF’s rethink of Postel’s robustness principle—being too “liberal” can harm ecosystems.)
  - **Hyrum’s Law beats SemVer.** Users depend on _any_ observable behavior. Version numbers help, but real safety comes from explicit compatibility promises, deprecation policies, and tests guarding behaviors. Check these before you trust a major/minor bump.
  - **Fit the org: socio-technical first.** Systems mirror team structures (Conway). Misaligned communication lines create defects (socio-technical incongruence). Keep cognitive load within team capacity; prefer tools that simplify mental models.
  - **Ecosystems compound value (and risk).** Network effects mean big communities, plugins, and docs often beat raw features. But compatibility choices shape lock-in vs. openness—probe standards support and portability.
  - **Prefer “boring” on critical paths; use maturity, not hype.** Put novelty at the edges. On the core, choose tech with long, dull track records. Assess maturity explicitly (e.g., TRL); don’t cargo-cult hype cycles.
  - **Plan your exit on day one (data gravity is real).** Data is hard to move; egress and inter-region transfer fees bite later. Check export formats, egress costs, and migration tooling up front; have a documented exit strategy.
  - **Bias to operability: kill toil.** Favor tools that reduce repetitive, manual ops (toil) via good automation surfaces (CLI/API), sane defaults, and low run-care. If it raises toil, it will tax innovation.
  - **Verify supply-chain & license posture, not just features.** Look for provenance/hardening (SLSA), secure development practices (NIST SSDF), and project health metrics (CHAOSS, OpenSSF Scorecard). Confirm license reality (e.g., SSPL is _not_ OSI-approved).
  - **Beware averages: optimize tails and guard against gamed metrics.** Real users feel 95th/99th-percentile latency and variability; read tail behavior and P-percentiles, not just means. And treat vendor benchmarks skeptically (Goodhart’s law; microbench pitfalls).
- Core Concepts of [Sleep](https://chatgpt.com/c/68cd59b3-005c-832d-806c-54003d272764)
  - Adults should sleep for 7+ hours. Too long / too long isn't as good.
  - Dark, cool rooms offer better sleep.
  - Sleeping & waking up at consistent times is a strong predictor of long-term health—sometimes stronger than raw duration.
  - NREM (especially slow-wave sleep) supports memory consolidation; REM helps integrate/emphasize emotional memories.
  - Caffeine and alcohol disrupt sleep.
- Core Concepts of [Encrypted Computation](https://chatgpt.com/c/68c63cb7-2e68-8323-8816-ea5f03e5e880)
  - **Computation is possible on ciphertexts** – you can add/multiply encrypted numbers without decrypting, and results decrypt correctly.
  - **Noise enables security but limits depth** – homomorphic schemes add noise that protects privacy but caps how many operations you can do before refresh.
  - **Bootstrapping makes “infinite” computation possible** – a slow but clever way to reset noise so you can keep computing forever.
  - **Partial homomorphism is often enough** – many real tasks only need addition _or_ multiplication, not full generality.
  - **Efficiency depends on algebra choice** – lattice, ring, or boolean encodings change speed/capabilities dramatically.
  - **Communication > computation in MPC** – secure multi-party protocols are bottlenecked more by network roundtrips than raw CPU.
  - **Trusted hardware ≠ silver bullet** – enclaves (SGX, SEV) protect data but side-channels and supply-chain risks remain.
  - **Exact correctness is traded for approximate math** – encrypted ML often relies on approximate arithmetic or quantization, counter-intuitive in “exact crypto.”
  - **Security can come from redundancy** – secret sharing splits data among parties so no one sees the whole, yet reconstruction is exact.
  - **Faster isn’t always weaker** – some of the most efficient schemes (like CKKS for approximate real numbers) are still provably secure under lattice assumptions.
- Core Concepts of [Computational Learning Theory](https://chatgpt.com/c/68c63cb7-2e68-8323-8816-ea5f03e5e880)
  1. **Simple models can generalize better than complex ones** — Occam’s razor + VC dimension: fewer parameters often mean more reliable learning.
  2. **More data beats better algorithms (up to a point)** — sample complexity often dominates computational tricks.
  3. **Weak learners can be boosted into strong ones** — AdaBoost shows that barely-better-than-random classifiers can combine into near-perfect ones.
  4. **Overfitting is sometimes useful** — in boosting, driving training error to zero can still yield good generalization.
  5. **Learning ≠ compression, but they are deeply linked** — Minimum Description Length shows compressibility and learnability align.
  6. **Hardness comes from representation, not data** — some concepts are provably unlearnable efficiently even if infinite labeled data exists (e.g., parity with noise).
  7. **Mistake-driven learning converges fast** — algorithms like Perceptron can guarantee convergence in bounded mistakes regardless of input size.
  8. **Noise can be fatal** — a small amount of adversarial noise can make some classes (e.g., DNFs) intractable to learn.
  9. **Margins matter more than accuracy** — large-margin classifiers (SVMs) generalize better even if training error is unchanged.
  10. **PAC-learnability ≠ practical learnability** — a concept might be learnable in theory with polynomial resources but hopeless in real data sizes.
- [Coding Theory](https://chatgpt.com/c/68c63cb7-2e68-8323-8816-ea5f03e5e880)
  1. **Redundancy helps** — Extra bits give the code “wiggle room” to catch mistakes, and clever design (like parity checks) keeps the added overhead small compared to the reliability gained.
  2. **Random codes work** — Random constructions spread information evenly, making it surprisingly hard for errors to concentrate, which theory shows can match or beat hand-crafted designs.
  3. **Error location > error correction** — If you know which positions are wrong (erasures), fixing them is algebraically much simpler than guessing both _where_ and _what_.
  4. **Longer blocks help** — With more symbols in a block, statistical averages smooth out, so the code can withstand more errors while still fitting within capacity bounds.
  5. **Decoding > design** — A code is only as useful as the algorithm that can decode it in practice; fast decoders like Viterbi or belief propagation made certain codes revolutionary.
  6. **Perfect codes exist but rare** — A few codes pack error spheres so tightly that they achieve theoretical limits, but geometry proves such “perfect fits” are exceptional cases.
  7. **Capacity is safe** — Shannon’s theorem guarantees that codes can approach the channel limit with vanishing error if block length grows, so pushing limits doesn’t mean fragility.
  8. **Non-linear sometimes wins** — While linear algebra simplifies design, special non-linear codes achieve distances or covering properties impossible for linear ones.
  9. **Detection is cheaper than correction** — Spotting that “something’s wrong” only needs a parity check, while correction requires enough redundancy to pinpoint and repair errors.
  10. **It’s geometry** — Error correction boils down to fitting non-overlapping “balls” in high-dimensional space; this geometric view explains limits and guides constructions.
- Core Concepts of Prioritization
  - Start with why. Align to purpose
  - De-bottleneck.
  - Pareto rule. Pick vital few tasks delivering most of the value
  - Impact × Effort matrix. Plot initiatives; attack quick wins, park drags.
- Core Concepts of Food safety at home: [US FDA / CDC](https://www.fda.gov/food/consumers/food-safety-education)
  - Clean
  - Separate
  - Cook
  - Chill
- Core Concepts of Everyday cooking: [Samin Nosrat’s framework](<https://en.wikipedia.org/wiki/Salt_Fat_Acid_Heat_(book)>)
  - Salt
  - Fat
  - Acid
  - Heat
- Core Concepts of Photography basics:
  - Exposure triangle (aperture, shutter speed, ISO)
- Core Concepts of CPR (lay rescuer): [American Heart Association](https://cpr.heart.org)
  - Compressions
  - Airway
  - Breathing
  - AED
- Core Concepts of First-aid primary survey: [Red Cross / St John](https://www.betterhealth.vic.gov.au/health/conditions-and-treatments/first-aid-basics-and-drsabcd)
  - Danger
  - Response
  - Send for help
  - Airway
  - Breathing
  - CPR
  - Defibrillation
- Core Concepts of Defensive driving: [National Safety Council](https://www.nsc.org/safety-training/defensive-driving)
  - Scan ahead
  - Safe gap
  - Speed control
  - Hazard anticipation
  - Seat-belt discipline
- Core Concepts of Strength training: [NSCA Essentials / ACSM](https://www.nsca.com/contentassets/ae95c28e2bdf43c7b69636eacd3e4c72/ptq3.2-3-principle-based_program_design.pdf)
  - Progressive overload
  - Specificity
  - Recovery
  - Variation
- Core Concepts of Project management: [PMI PMBOK®](https://www.pmi.org/pmbok-guide-standards/foundational/pmbok)
  - Initiate
  - Plan
  - Execute
  - Monitor/Control
  - Close
- Core Concepts of Scrum/Agile teamwork: [The Scrum Guide](https://scrumguides.org)
  - Transparency
  - Inspection
  - Adaptation
  - Sprint cycle
- Core Concepts of Negotiation: [Harvard Program on Negotiation](https://www.pon.harvard.edu)
  - BATNA
  - ZOPA
  - Interests-not-positions
  - Anchoring
- Core Concepts of Public speaking: [Toastmasters Competent Communication manual](https://oldtowntoastmasters.org/wp-content/uploads/2021/04/Toastmasters-CC-Manual.pdf)
  - Speech purpose
  - Organization
  - Vocal variety
  - Body language
  - Persuasion
- Core Concepts of Cyber hygiene: [NIST Cybersecurity Basics](https://www.nist.gov/itl/smallbusinesscyber/cybersecurity-basics)
  - Strong unique passwords
  - Multi-factor authentication
  - Patch/update habit
  - Regular backups
  - Phishing skepticism
- Core Concepts of Home gardening: [US Master Gardener “Earth-Kind” principles](https://ccmgatx.org/resources/articles/article-repository/2021/may/right-plant-right-place/)
  - Right plant, right place
  - Soil preparation
  - Water management
  - Mulching
  - Integrated pest management (IPM)
- Core Concepts of Wilderness survival: [US Army Survival manual FM 21-76](https://dn790002.ca.archive.org/0/items/Fm21-76SurvivalManual/FM21-76_SurvivalManual.pdf)
  1. Shelter
  2. Water
  3. Fire
  4. Food
  5. Signaling for rescue
- Core Concepts of Personal productivity: [David Allen’s GTD](https://www.float.com/resources/getting-things-done-method)
  - Capture
  - Clarify
  - Organize
  - Reflect
  - Engage
- Core Concepts of Emotional intelligence: [Daniel Goleman’s EQ framework](https://www.verywellmind.com/components-of-emotional-intelligence-2795438)
  - Self-awareness
  - Self-regulation
  - Motivation
  - Empathy
  - Social skill
- Core Concepts of Design thinking: [Stanford d.school / IDEO](https://makeiterate.com/the-stanford-design-thinking-process/)
  - Empathize
  - Define
  - Ideate
  - Prototype
  - Test
- Core Concepts of Personal finance: [US Financial Literacy & Education Commission](https://www.mymoney.gov/mymoneyfive)
  - Earn
  - Spend
  - Save & invest
  - Borrow
  - Protect
- Core Concepts of Persuasion:
  - [Cialdini](https://worldofwork.io/2019/07/cialdinis-6-principles-of-persuasion):
    - **Reciprocity** – Give value first so people feel socially obliged to return the favour.
    - **Scarcity** – Emphasise limited supply or time to heighten desire and urgency.
    - **Authority** – Display credible expertise or endorsement to trigger compliance reflexes.
    - **Commitment / Consistency** – Secure a small voluntary pledge so people keep acting in line with it.
    - **Social proof** – Show peers already behaving this way to leverage herd instincts.
    - **Liking** – Build rapport and similarity because we say “yes” more to people we like.
  - [Aristotle](https://www.lsu.edu/hss/english/files/university_writing_files/item35402.pdf):
    - **Ethos** – Project trustworthy character so the audience believes you.
    - **Pathos** – Arouse emotion to make the message feel personally important.
    - **Logos** – Use clear logic and evidence to satisfy rational scrutiny.
  - [Monroe's Motivated Sequence](https://www.gvsu.edu/speechlab/monroes-motivated-sequence-46.htm)
    - **Attention** – Grab focus instantly with a vivid hook.
    - **Need** – Prove a pressing problem that demands action.
    - **Satisfaction** – Show how your solution meets that need.
    - **Visualization** – Paint the future benefit (or risk) to make outcomes tangible.
    - **Action** – Specify the exact next step you want the audience to take now.
- Core Concepts of Meditation:
  - **Intention** – Begin with a clear purpose for practising (e.g., calm, insight, compassion).
  - **Attention** – Hold steady, non-reactive focus on a chosen object like breath or body.
  - **Attitude** – Maintain a kind, curious, non-judging stance toward whatever arises.
  - **Attention regulation** – Train concentration so the mind wanders less and returns faster.
  - **Body awareness** – Refine sensitivity to internal sensations and posture.
  - **Emotion regulation** – Observe feelings without suppression or over-identification, letting them pass.
  - **Perspective on self** – See thoughts and self-images as transient events, not fixed identity.
- Core Concepts of Software Validation (testing): [FDA](https://www.fda.gov/regulatory-information/search-fda-guidance-documents/general-principles-software-validation) [Public Health](https://health.ec.europa.eu/system/files/2016-11/annex11_01-2011_en_0.pdf) [PIC/S](https://picscheme.org/)
  - **Lifecycle validation** – Plan → specify → build/configure → verify/qualify → release → operate/maintain → retire; evidence at every step.
  - **Risk‑based approach** – Focus validation effort where failure impacts product quality, patient safety, or data integrity most.
  - **Documented evidence & traceability** – Link user requirements → functional/spec docs → test cases/results; auditors must see the chain.
  - **Data integrity (ALCOA+)** – Data must be Attributable, Legible, Contemporaneous, Original, Accurate—plus Complete, Consistent, Enduring, Available.
  - **Change control & configuration management** – Every change is assessed for risk, approved, tested, and documented before release.
  - **Supplier / service provider qualification** – Assess vendors (SaaS, cloud, integrators) and maintain quality agreements; you retain regulatory responsibility.
  - **Qualification phases (IQ/OQ/PQ)** – Prove correct installation, operation against specs, and performance in the real process.
  - **Validation Master Plan (VMP) & system-level plans/reports** – Define scope, approach, roles, deliverables; close with a report justifying the release decision.
  - **Security, access control, audit trails, e‑signatures** – Ensure only authorised actions, full traceability, and Part 11/Annex 11 compliant records.
  - **Periodic review & continuous monitoring** – Re-evaluate systems, data integrity, and risk; ensure backups, disaster recovery, and business continuity work.
  - **Deviation/CAPA management** – Record incidents, investigate root causes, implement corrective and preventive actions.
  - **Training & SOPs** – People running and maintaining the system need role-appropriate training and controlled procedures.
